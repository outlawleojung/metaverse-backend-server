import { InjectRedis } from '@liaoliaots/nestjs-redis';
import { Inject, Injectable, Logger, forwardRef } from '@nestjs/common';
import { Redis } from 'ioredis';
import { Server, Socket } from 'socket.io';
import { v4 as uuidv4 } from 'uuid';

import { TokenCheckService } from '../manager/auth/tocket-check.service';
import { RedisFunctionService } from '@libs/redis';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import {
  CreateFriendChatting,
  OneOnOneChattingLog,
  RoomDataLog,
  WorldChattingLog,
} from '@libs/mongodb';
import { CreateFriendChattingRoom } from '@libs/mongodb';
import { ChattingMemberInfo } from '@libs/mongodb';
import { CommonService } from '@libs/common';
import { Repository } from 'typeorm';
import { Member, MemberOfficeVisitLog } from '@libs/entity';
import { InjectRepository } from '@nestjs/typeorm';
import moment from 'moment-timezone';
import { NatsService } from '../nats/nats.service';
import { ChatGateway } from './chat.gateway';
import { NatsMessageHandler } from '../nats/nats-message.handler';
import {
  CHATTING_SOCKET_S_MESSAGE,
  NATS_EVENTS,
  RedisKey,
  SOCKET_SERVER_ERROR_CODE_GLOBAL,
} from '@libs/constants';

@Injectable()
export class ChatService_V2 {
  private readonly logger = new Logger(ChatService_V2.name);
  constructor(
    @InjectRedis() private readonly redisClient: Redis,
    @InjectModel('createFriendChattingRoom')
    private readonly createFriendChattingRoom: Model<CreateFriendChattingRoom>,
    @InjectModel('createFriendChatting')
    private readonly createFriendChatting: Model<CreateFriendChatting>,
    @InjectModel('chattingMemberInfo')
    private readonly chattingMemberInfo: Model<ChattingMemberInfo>,
    @InjectModel('worldChattingLog')
    private readonly worldChattingLog: Model<WorldChattingLog>,
    @InjectModel('oneononeChattingLog')
    private readonly oneononeChattingLog: Model<OneOnOneChattingLog>,
    @InjectModel('roomDataLog')
    private readonly roomDataLog: Model<RoomDataLog>,
    @InjectRepository(Member) private memberRepository: Repository<Member>,
    @InjectRepository(MemberOfficeVisitLog)
    private memberOfficeVisitLogRepository: Repository<MemberOfficeVisitLog>,
    @Inject(forwardRef(() => ChatGateway))
    private readonly chatGateway: ChatGateway,
    private readonly messageHandler: NatsMessageHandler,
    private readonly natsService: NatsService,
    private readonly tokenCheckService: TokenCheckService,
    private readonly redisFunctionService: RedisFunctionService,
    private readonly commonService: CommonService,
  ) {}

  private socketMap = new Map();
  getSocket(sessionId: string) {
    return this.socketMap.get(sessionId);
  }

  // ÏÜåÏºì Ïó∞Í≤∞
  async handleConnection(
    server: Server,
    client: Socket,
    jwtAccessToken: string,
    sessionId: string,
  ) {
    const memberInfo =
      await this.tokenCheckService.checkLoginToken(jwtAccessToken);

    // Ìï¥Îãπ Î©§Î≤ÑÍ∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùÑ Í≤ΩÏö∞ Ïó∞Í≤∞ Ï¢ÖÎ£å
    if (!memberInfo) {
      client.disconnect();
      return;
    }

    const memberId = memberInfo.memberId;
    const clientId = memberInfo.memberCode;

    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏÑ§Ï†ï
    client.data.memberId = memberId;
    client.data.sessionId = sessionId;
    client.data.jwtAccessToken = jwtAccessToken;
    client.data.clientId = clientId;

    // ÎÇòÏùò Î£∏ Íµ¨ÎèÖÏùÑ Ï∂îÍ∞ÄÌïúÎã§.
    this.messageHandler.registerHandler(memberId, (message) => {
      const sendMessages = JSON.parse(message);

      console.log('DM Ïù¥Î≤§Ìä∏ Î∞úÏÉù ');
      console.log(message);

      client.emit(
        CHATTING_SOCKET_S_MESSAGE.S_SEND_DIRECT_MESSAGE,
        JSON.stringify(sendMessages.recvmessageInfo),
      );
    });

    client.join(memberId);
    client.join(sessionId);

    this.socketMap.set(sessionId, client);

    this.logger.debug(
      `Ï±ÑÌåÖ ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ÎêòÏóàÏñ¥Ïöî ‚úÖ : ${memberId} - sessionId : ${sessionId}`,
    );
  }

  async handleDisconnect(client: Socket) {
    this.logger.debug(`ÏÇ≠Ï†ú ÎêòÎäî RoomId :  ${client.data.roomId}`);
    this.logger.debug(`ÏÇ≠Ï†ú ÎêòÎäî memberId :  ${client.data.memberId}`);

    const playerIds = await this.redisClient.smembers(
      RedisKey.getStrRoomPlayerList(client.data.roomId),
    );

    // Î£∏Ïóê ÌòºÏûê ÏûàÏóàÏùÑ Í≤ΩÏö∞ Î£∏ Í¥ÄÎ†® Îç∞Ïù¥ÌÑ∞ Î™®Îëê ÏÇ≠Ï†ú
    if (playerIds.length === 1) {
      // Î†àÎîîÏä§ Î£∏ Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
      await this.redisClient.del(`${client.data.roomId}`);

      // Î£∏ Íµ¨ÎèÖ Ìï¥Ï†ú
      await this.messageHandler.publishHandler(
        NATS_EVENTS.DELETE_CHAT_ROOM,
        client.data.roomId,
      );
    }
    await this.redisClient.srem(
      RedisKey.getStrRoomPlayerList(client.data.roomId),
      client.data.memberId,
    );

    const memberKey = RedisKey.getStrMemberCurrentRoom(client.data.memberId);
    await this.redisClient.del(memberKey);

    // Íµ¨ÎèÖ Ìï¥Ï†ú
    this.messageHandler.removeHandler(client.data.memberId);

    // ÏÜåÏºì Îßµ Ï†ïÎ≥¥ÏóêÏÑú ÏÇ≠Ï†ú
    const entriesToRemove = [...this.socketMap.entries()].filter(
      ([_, v]) => v.id === client.id,
    );
    entriesToRemove.forEach(([key]) => this.socketMap.delete(key));

    this.logger.debug('Ï±ÑÌåÖ ÏÜåÏºì Ïó∞Í≤∞ Ìï¥Ï†ú ‚ùå : ' + client.id);
  }

  // Î∞© ÏûÖÏû•
  async joinRoom(message: string) {
    const roomInfo = JSON.parse(message);
    const roomId: string = roomInfo.roomId;
    const redisRoomId = RedisKey.getStrRoomId(roomId);
    const memberId = roomInfo.memberId;

    try {
      const socketInfo = await this.redisClient.get(
        RedisKey.getStrMemberSocket(memberId),
      );

      const socketData = JSON.parse(socketInfo);

      const socket: Socket = await this.getSocket(socketData.sessionId);

      if (socket) {
        socket.data.roomName = roomInfo?.roomName;
        socket.data.roomCode = roomInfo?.roomCode;
        socket.data.sceneName = roomInfo.sceneName;
        socket.data.roomId = redisRoomId;
        socket.join(redisRoomId);

        this.logger.debug('Ï±ÑÌåÖ ÏÑúÎ≤Ñ Î£∏ ÏûÖÏû•.üÜó : ', redisRoomId);

        // Î£∏ Íµ¨ÎèÖ
        await this.messageHandler.registerHandler(
          `${NATS_EVENTS.CHAT_ROOM}.${redisRoomId}`,
          async (message) => {
            this.chatGateway.server
              .to(redisRoomId)
              .emit(CHATTING_SOCKET_S_MESSAGE.S_SEND_MESSAGE, message);
          },
        );

        // Î£∏Ïóê Ìá¥Ïû• Ï†ïÎ≥¥ Íµ¨ÎèÖ
        await this.messageHandler.registerHandler(
          `${NATS_EVENTS.LEAVE_ROOM}:${memberId}`,
          async (data) => {
            // Î£∏ Ìá¥Ïû•
            await this.leaveRoom(data);
          },
        );
      }

      // MongoDBÏóê Î∞© ÏûÖÏû• Î°úÍ∑∏ Í∏∞Î°ù
      const kstCreatedAt = moment
        .tz('Asia/Seoul')
        .format('YYYY-MM-DD HH:mm:ss');

      const roomDataLogArr = new this.roomDataLog({
        memberId: memberId,
        nickName: roomInfo.nickname,
        roomName: roomInfo.roomName,
        roomCode: roomInfo.roomCode,
        description: 'ÏûÖÏû•',
        kstCreatedAt,
      });

      await roomDataLogArr.save();

      // TypeORMÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ MySQLÏóê Î∞©Î¨∏ Î°úÍ∑∏ Ï†ÄÏû•
      if (roomInfo.roomCode) {
        const mysqlRoomDataLogArr = new MemberOfficeVisitLog();
        mysqlRoomDataLogArr.memberId = memberId;
        mysqlRoomDataLogArr.roomCode = roomInfo.roomCode;

        await this.memberOfficeVisitLogRepository.save(mysqlRoomDataLogArr);
      }
    } catch (error) {
      this.logger.debug('Ï±ÑÌåÖ ÏÑúÎ≤ÑÍ∞Ä Î£∏ ÏûÖÏû• Ïã§Ìå®.‚ùå : ', redisRoomId);
      this.logger.debug({ error });
    }
  }

  // Î∞© Ìá¥Ïû•
  async leaveRoom(data: string) {
    const roomInfo = JSON.parse(data);

    const roomId = roomInfo.roomId;
    const redisRoomId = RedisKey.getStrRoomId(roomId);

    const memberId = roomInfo.memberId;

    const socketInfo = await this.redisClient.get(
      RedisKey.getStrMemberSocket(memberId),
    );
    const socketData = JSON.parse(socketInfo);

    const socket: Socket = await this.getSocket(socketData.sessionId);

    socket.leave(redisRoomId);

    socket.data.roomName = '';
    socket.data.roomCode = '';

    this.logger.debug(`Ï±ÑÌåÖ ÏÑúÎ≤ÑÍ∞Ä Î£∏ Ìá¥Ïû•. ‚ùå ${memberId} - ${redisRoomId}`);

    const kstCreatedAt = moment.tz('Asia/Seoul').format('YYYY-MM-DD HH:mm:ss');
    // Î∞© Ìá¥Ïû• Î°úÍ∑∏ Í∏∞Î°ù
    const roomDataLogArr = await new this.roomDataLog({
      memberId: socket.data.memberId,
      nickName: socket.data.nickname,
      roomName: socket.data.roomName,
      roomCode: socket.data.roomCode,
      description: 'Ìá¥Ïû• ',
      kstCreatedAt: kstCreatedAt,
    });

    await roomDataLogArr.save();
  }

  // Î©îÏÑ∏ÏßÄ Î≥¥ÎÇ¥Í∏∞
  async sendMessage(
    client: Socket,
    jwtAccessToken: string,
    message: string,
    roomCode: string,
    roomName: string,
    color: string,
  ) {
    const memberInfo =
      await this.tokenCheckService.checkLoginToken(jwtAccessToken);

    if (!memberInfo) {
      client.disconnect();
      return;
    }

    const messageInfo = {
      sendNickName: memberInfo.nickname,
      message: message,
      color: color,
    };

    client.data.roomCode = roomCode;

    const findMemberCode = await this.memberRepository.findOne({
      where: {
        memberId: memberInfo.memberId,
      },
    });

    const kstCreatedAt = moment.tz('Asia/Seoul').format('YYYY-MM-DD HH:mm:ss');
    const worldChattingLogSave = await new this.worldChattingLog({
      memberId: memberInfo.memberId,
      memberCode: findMemberCode.memberCode,
      nickName: memberInfo.nickname,
      roomCode: roomCode,
      roomName: roomName, // Î£∏ÏΩîÎìúÍ∞Ä ÏïàÎÑòÏñ¥Ïò¨ Ïàò ÏûàÏñ¥ÏÑú ÏïàÎê† Ïàò ÏûàÏúºÎãà ÌÖåÏä§Ìä∏ Ìï¥Î¥êÏïºÌï®
      roomId: client.data.roomId,
      chatMessage: message,
      kstCreatedAt: kstCreatedAt,
    });
    await worldChattingLogSave.save();

    this.messageHandler.publishHandler(
      `${NATS_EVENTS.CHAT_ROOM}.${client.data.roomId}`,
      JSON.stringify(messageInfo),
    );
  }

  // ÏõîÎìú Í∑ìÏÜçÎßê ÌäπÏ†ï ÏÜåÏºìÏóêÎßå Î©îÏÑ∏ÏßÄ Ï†ÑÏÜ°
  async sendDirectMessage(
    client: Socket,
    payload: {
      recvNickName: string;
      message: string;
      color: string;
    },
  ) {
    if (!payload.recvNickName) {
      return client.emit(
        CHATTING_SOCKET_S_MESSAGE.S_SYSTEM_MESSAGE,
        SOCKET_SERVER_ERROR_CODE_GLOBAL.DIRECT_MESSAGE_USER_NOT_FOUND,
      );
    }

    const recvNickNameMember = await this.memberRepository.findOne({
      where: {
        nickname: payload.recvNickName,
      },
    });

    // Í∑ìÏÜçÎßê ÎåÄÏÉÅÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÏÇ¨Ïö©ÏûêÏùº Í≤ΩÏö∞
    if (!recvNickNameMember) {
      return client.emit(
        CHATTING_SOCKET_S_MESSAGE.S_SYSTEM_MESSAGE,
        SOCKET_SERVER_ERROR_CODE_GLOBAL.DIRECT_MESSAGE_USER_NOT_FOUND,
      );
    }

    // Í∑ìÏÜçÎßê ÎåÄÏÉÅÏù¥ ÌòÑÏû¨ Ïò§ÌîÑÎùºÏù∏Ïùº Í≤ΩÏö∞
    const targetSocket = await this.redisClient.get(
      RedisKey.getStrMemberSocket(recvNickNameMember.memberId),
    );

    const sendNickNameMember = await this.memberRepository.findOne({
      where: {
        memberId: client.data.memberId,
      },
    });

    // Î≥∏Ïù∏ÏóêÍ≤å Í∑ìÏÜçÎßê Î≥¥ÎÉàÏùÑ Í≤ΩÏö∞
    if (sendNickNameMember.nickname == recvNickNameMember.nickname) {
      return client.emit(
        CHATTING_SOCKET_S_MESSAGE.S_SYSTEM_MESSAGE,
        SOCKET_SERVER_ERROR_CODE_GLOBAL.DIRECT_MESSAGE_SEND_ME,
      );
    }

    // Í∑ìÏÜçÎßê ÎåÄÏÉÅÏù¥ ÌòÑÏû¨ Ïò§ÌîÑÎùºÏù∏Ïùº Í≤ΩÏö∞
    if (!targetSocket) {
      return client.emit(
        CHATTING_SOCKET_S_MESSAGE.S_SYSTEM_MESSAGE,
        SOCKET_SERVER_ERROR_CODE_GLOBAL.DIRECT_MESSAGE_USER_NOT_CONNECTED,
      );
    }

    const kstCreatedAt = moment.tz('Asia/Seoul').format('YYYY-MM-DD HH:mm:ss');
    // mongodb Ï±ÑÌåÖ Î°úÍ∑∏ Ï†ÄÏû•
    const oneononeChattingLogSave = await new this.oneononeChattingLog({
      sendMemberId: sendNickNameMember.memberId,
      sendNickName: sendNickNameMember.nickname,
      recvMemberId: recvNickNameMember.memberId,
      recvNickName: recvNickNameMember.nickname,
      chatMessage: payload.message,
      kstCreatedAt: kstCreatedAt,
    });
    await oneononeChattingLogSave.save();

    const recvmessageInfo = {
      sendNickName: sendNickNameMember.nickname,
      recvNickName: recvNickNameMember.nickname,
      message: payload.message,
      color: payload.color,
    };

    const sendMessageInfo = {
      recvNickName: recvNickNameMember.nickname,
      message: payload.message,
      color: payload.color,
    };

    const sendMessages = {
      recvmessageInfo,
      sendMessageInfo,
    };

    this.messageHandler.publishHandler(
      recvNickNameMember.memberId,
      JSON.stringify(sendMessages),
    );

    client.emit(
      CHATTING_SOCKET_S_MESSAGE.S_SEND_DIRECT_MESSAGE,
      JSON.stringify(sendMessageInfo),
    );
  }

  // ÏπúÍµ¨ Ï±ÑÌåÖ Î∞© ÎßåÎì§Í∏∞
  async createFriendDirectMessageRooms(client: Socket, targetMemberId: any) {
    const memberId = client['data'].memberId;
    const roomId = uuidv4();

    const newChattingRoom = await new this.createFriendChattingRoom({
      roomId: roomId,
      memberIds: [memberId, targetMemberId],
    });

    await newChattingRoom.save();

    // Î≥∏Ïù∏ Ï†ïÎ≥¥Ïóê Î∞© Ï∂îÍ∞Ä
    const existingMemberChattingRoomInfo =
      await this.chattingMemberInfo.findOne({ memberId: memberId });
    if (existingMemberChattingRoomInfo) {
      // Î¨∏ÏÑúÍ∞Ä Ï°¥Ïû¨Ìï† Í≤ΩÏö∞, Ìï¥Îãπ Î¨∏ÏÑúÏùò rooms ÌïÑÎìúÏóê roomIdÎ•º Ï∂îÍ∞ÄÌï©ÎãàÎã§.
      existingMemberChattingRoomInfo.rooms.push(roomId);

      // Î≥ÄÍ≤ΩÎêú Ï†ïÎ≥¥Î•º Ï†ÄÏû•Ìï©ÎãàÎã§.
      await existingMemberChattingRoomInfo.save();

      console.log(
        `Member ${memberId}'s rooms updated: `,
        existingMemberChattingRoomInfo,
      );
    } else {
      const newMemberChattingRoomInfo = await new this.chattingMemberInfo({
        memberId: memberId,
        rooms: [roomId],
      });
      await newMemberChattingRoomInfo.save();
    }

    // ÏÉÅÎåÄ Ï†ïÎ≥¥Ïóê Î∞© Ï∂îÍ∞Ä
    const existingTargetMemberChattingRoomInfo =
      await this.chattingMemberInfo.findOne({ memberId: targetMemberId });
    if (existingTargetMemberChattingRoomInfo) {
      // Î¨∏ÏÑúÍ∞Ä Ï°¥Ïû¨Ìï† Í≤ΩÏö∞, Ìï¥Îãπ Î¨∏ÏÑúÏùò rooms ÌïÑÎìúÏóê roomIdÎ•º Ï∂îÍ∞ÄÌï©ÎãàÎã§.
      existingTargetMemberChattingRoomInfo.rooms.push(roomId);

      // Î≥ÄÍ≤ΩÎêú Ï†ïÎ≥¥Î•º Ï†ÄÏû•Ìï©ÎãàÎã§.
      await existingTargetMemberChattingRoomInfo.save();

      console.log(
        `Member ${targetMemberId}'s rooms updated: `,
        existingTargetMemberChattingRoomInfo,
      );
    } else {
      const newTargetMemberChattingRoomInfo = await new this.chattingMemberInfo(
        {
          memberId: targetMemberId,
          rooms: [roomId],
        },
      );
      await newTargetMemberChattingRoomInfo.save();
    }

    return roomId;
  }

  // ÏπúÍµ¨ÏóêÍ≤å Îã§Ïù¥Î†âÌä∏ Î©îÏÑ∏ÏßÄ Ï†ÑÏÜ°
  async sendFriendDirectMessage(
    client: Socket,
    targetMemberId: any,
    message: string,
  ) {
    const memberId = client['data'].memberId;

    const messageId = uuidv4();

    const findChattingRoom = await this.createFriendChattingRoom.findOne({
      $and: [{ memberIds: memberId }, { memberIds: targetMemberId }],
    });

    console.log('Ï±ÑÌåÖ Î£∏ÏùÑ Ï∞æÏïÑÎ≥ºÍ≤åÏöî');
    console.log(findChattingRoom);
    // Ï±ÑÌåÖ Î∞©Ïù¥ ÏóÜÏúºÎ©¥ Ï±ÑÌåÖ Î∞© ÎßåÎì§Í∏∞
    if (findChattingRoom === null) {
      const room = await this.createFriendDirectMessageRooms(
        client,
        targetMemberId,
      );

      console.log('Î£∏ ÎßåÎì†Îã§~~~~~~~');
      console.log(room);
      const newChatting = await new this.createFriendChatting({
        messageId: messageId,
        roomId: room,
        memberId: memberId,
        message: message,
        unReadMembers: [targetMemberId],
      });
      await newChatting.save();
    } else {
      console.log('Ï±ÑÌåÖ Î£∏ÏùÑ Ï∞æÏïòÏñ¥Ïöî');
      console.log(findChattingRoom);

      const roomId = findChattingRoom.roomId;
      console.log('Ï±ÑÌåÖ Î£∏ ÏïÑÏù¥Îîî ^^');
      console.log(roomId);
      const newChatting = await new this.createFriendChatting({
        messageId: messageId,
        roomId: roomId,
        memberId: memberId,
        message: message,
        unReadMembers: [targetMemberId],
      });
      await newChatting.save();
    }

    client.emit(
      CHATTING_SOCKET_S_MESSAGE.S_SEND_FRIEND_DIRECT_MESSAGE,
      `[DM]${targetMemberId}ÏóêÍ≤å Î≥¥ÎÇ∏ Î©îÏÑ∏ÏßÄ:${message}`,
    );

    // ÌäπÏ†ï Î∞©Ïóê Ï†ëÏÜçÌï¥ÏûàÎäî ÌäπÏ†ï ÏÜåÏºìÏóêÍ≤åÎßå Î©îÏÑ∏ÏßÄ Ï†ÑÏÜ°
    client
      .to(targetMemberId)
      .emit(
        CHATTING_SOCKET_S_MESSAGE.S_SEND_FRIEND_DIRECT_MESSAGE,
        `[DM]${client['data'].memberId}Í∞Ä Î≥¥ÎÇ∏ Î©îÏÑ∏ÏßÄ :${message}`,
      );

    console.log('Ï†ÄÏû•ÌñàÏòπ');
  }

  // ÏπúÍµ¨ Ï±ÑÌåÖ Îß§ÏÑ∏ÏßÄ Î¶¨Ïä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
  async getFriendDirectMessageList(client: Socket) {
    const memberId = client['data'].memberId;

    // Ï±ÑÌåÖÎ∞© Î™©Î°ù
    const chattingList = [];

    // Ï†ëÏÜç Ï§ëÏù∏ Ï±ÑÌåÖÎ∞© Ï†ÑÏ≤¥ Î∂àÎü¨Ïò§Í∏∞
    const findChattingRoom = await this.chattingMemberInfo.find({
      memberId: memberId,
    });

    const member = await this.memberRepository.findOne({
      where: {
        memberId: memberId,
      },
    });

    // ÏïÑÎ∞îÌÉÄ Ï†ïÎ≥¥Î•º Ï°∞Ìöå
    const avatarInfo = await this.commonService.getMemberAvatarInfo(
      member.memberCode,
    );

    // Î∞©Ïóê ÏûàÎäî ÎßàÏßÄÎßâ Ï±ÑÌåÖ ÎÇ¥Ïö© ÌïòÎÇòÏî©Îßå Î∂àÎü¨Ïò§Í∏∞
    if (findChattingRoom && findChattingRoom.length > 0) {
      for (let i = 0; i < findChattingRoom[0].rooms.length; i++) {
        console.log('Î∞©Ïóê ÏûàÎäî Ï±ÑÌåÖ ÎÇ¥Ïö© Î∂àÎü¨Ïò§Í∏∞');
        console.log(findChattingRoom[0].rooms[i]);

        //createdAt Í∏∞Ï§ÄÏúºÎ°ú ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨ ÌõÑ, limit 1Í∞úÎßå Í∞ÄÏ†∏Ïò§Í∏∞
        const findChatting = await this.createFriendChatting
          .find({
            roomId: findChattingRoom[0].rooms[i],
          })
          .sort({ createdAt: -1 })
          .limit(1);

        //Ï±ÑÌåÖ ÎÇ¥Ïö©
        console.log(findChatting);

        //findChattting ÎÇ¥Ïóê ÏûàÎäî unreadMembers Î∞∞Ïó¥Ïóê memberIdÍ∞Ä ÏûàÎäîÏßÄ Í∞úÏàòÎßåÌÅº ÌôïÏù∏
        //ÏïàÏùΩÏùÄ Îß§ÏÑ∏ÏßÄ Í∞úÏàò ÌôïÏù∏
        const findUnreadChatting = await this.createFriendChatting.find({
          roomId: findChattingRoom[0].rooms[i],
          unReadMembers: { $in: [memberId] },
        });

        chattingList.push({
          chattingList: findChatting,
          unReadCount: findUnreadChatting.length,
          avatarInfo: avatarInfo,
        });
      }
      return chattingList;
    }
  }

  // ÏπúÍµ¨ Îã§Ïù¥Î†âÌä∏ Îß§ÏÑ∏ÏßÄ Í∞ÄÏ†∏Ïò§Í∏∞
  async getFriendDirectMessage(client: Socket, roomId: string) {
    //ÌÖåÏä§Ìä∏Î•º ÏúÑÌï¥ ÏûÑÏùòÎ°ú DTO ÏÉÅÏàò ÏÑ†Ïñ∏
    const paginationDto = {
      page: 1,
      limit: 10,
    };

    const page = paginationDto.page ? paginationDto.page : 1;
    const limit = paginationDto.limit ? paginationDto.limit : 10;
    const skip = (page - 1) * limit;
    const findChatting = await this.createFriendChatting
      .find({
        roomId: roomId,
      })
      .skip(skip)
      .limit(limit);

    console.log('ÏπúÍµ¨ Ï±ÑÌåÖ ÎÇ¥Ïö© Î∂àÎü¨Ïò§Í∏∞ ÌéòÏù¥ÏßÄ ÎÑ§Ïù¥ÏÖò ~ ~ ~~ ');
    console.log(findChatting);
  }

  // Ï±ÑÌåÖ Î∞© ÎÇòÍ∞ÄÍ∏∞
  async exitChatRoom(client: Socket, roomId: string) {
    this.logger.debug('Ï±ÑÌåÖ Î∞© Ìá¥Ïû• Ïù¥Î≤§Ìä∏ Î∞úÏÉù : ' + roomId);
    const playerIds = await this.redisClient.smembers(
      RedisKey.getStrRoomPlayerList(roomId),
    );

    console.log(playerIds);

    // Î£∏Ïóê ÏÇ¨Ïö©ÏûêÍ∞Ä Î≥∏Ïù∏ 1Î™Ö ÎøêÏù¥ÎùºÎ©¥ Î£∏ ÏÇ≠Ï†ú
    if (playerIds.length === 1) {
      await this.redisClient.del(roomId);

      await this.messageHandler.publishHandler(
        NATS_EVENTS.DELETE_CHAT_ROOM,
        roomId,
      );
    }

    // Î£∏ ÏÇ¨Ïö©Ïûê Î¶¨Ïä§Ìä∏ÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏÇ≠Ï†ú
    await this.redisClient.srem(
      RedisKey.getStrRoomPlayerList(roomId),
      client.data.memberId,
    );

    await this.redisFunctionService.updateJson(
      RedisKey.getStrMemberSocket(client.data.memberId),
      'roomId',
      '',
    );

    // Í∏∞Ï°¥ Î£∏ÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†úÍ±∞
    const memberKey = RedisKey.getStrMemberCurrentRoom(client.data.memberId);
    await this.redisClient.del(memberKey);

    const kstCreatedAt = moment.tz('Asia/Seoul').format('YYYY-MM-DD HH:mm:ss');
    // Î∞© Ìá¥Ïû• Î°úÍ∑∏ Í∏∞Î°ù
    const roomDataLogArr = await new this.roomDataLog({
      memberId: client.data.memberId,
      nickName: client.data.nickname,
      roomName: client.data.roomName,
      roomCode: client.data.roomCode,
      description: 'Ìá¥Ïû• ',
      kstCreatedAt: kstCreatedAt,
    });

    await roomDataLogArr.save();
    client.leave(roomId);

    client.data.roomName = '';
    client.data.roomCode = '';

    // Î£∏ Ìá¥Ïû• Ïù¥Î≤§Ìä∏ Î∞úÏÉù
    await this.messageHandler.publishHandler(
      `${NATS_EVENTS.LEAVE_ROOM}:${client.data.memberId}`,
      JSON.stringify({
        memberId: client.data.memberId,
        roomId: client.data.roomId,
      }),
    );
  }

  // Î∞© Í∞ÄÏ†∏Ïò§Í∏∞
  async getChatRoom(client: Socket, roomId: string) {
    if (
      !this.redisClient.get(roomId) ||
      this.redisClient.get(roomId) === undefined
    ) {
      return client.emit(
        CHATTING_SOCKET_S_MESSAGE.S_SEND_MESSAGE,
        'ÏïåÎ¶º : Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Î∞©ÏûÖÎãàÎã§.',
      );
    }

    const room = await this.redisClient.get(roomId);

    return JSON.parse(room).roomName;
  }

  // Ï†ëÏÜçÏ§ëÏù∏ ÏÇ¨Ïö©Ïûê ÎãâÎÑ§ÏûÑ Î¶¨Ïä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
  async getPlayerList(client: Socket) {
    const playerList = await this.redisClient.keys('socket:*');
    const playerNickNameList = [];

    // playerList ÏàúÏ∞®Ï†ÅÏúºÎ°ú Ï°∞ÌöåÌïòÎ©¥ÏÑú ÎãâÎÑ§ÏûÑÎßå Ï∂îÏ∂ú

    for (const p of playerList) {
      const player = await this.redisClient.get(p);
      playerNickNameList.push(JSON.parse(player).nickname);
    }

    client.emit('GetConnectedClientList', JSON.stringify(playerNickNameList));
  }

  // Î∞© ÏÇ≠Ï†ú
  async deleteChatRoom(roomId: string) {
    // redisÏóêÏÑú Î∞© ÏÇ≠Ï†ú
    await this.redisClient.del(roomId);

    // Íµ¨ÎèÖ Ìï¥Ï†ú
    this.natsService.unsubscribe(roomId);
  }
}
